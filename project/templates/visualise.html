<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <style>
        .border {
            border: 3px solid green;
        }

        .options {
            font-size: 12px;
        }

        .alt1 {
            background-color: aquamarine;
        }

        .alt2 {
            background-color: aqua;
        }
    </style>
</head>
<body>
    <script src="../static/js/jquery-3.3.1.min.js"></script>
    Welcome to PDPC_Coin <b>Visualiser:</b><br />
    <button type="button" class="options" id="test">test</button>
    <select id="viewsizes" class="options">
        <option value="1">small</option>
        <option value="3">medium</option>
        <option value="5">large</option>
    </select>
    Show Control: <input type="checkbox" id="ctrl">Show page: <input type="checkbox" id="GUI"><br /><br />
    <div id="control"></div>
    <div class="iframes" id="views">
        <table id="sets">
            <tr>
                <td class="options">
                    Scan: <input type="checkbox" id="scan"><br />
                    <button type="button" class="options" onClick="JavaScript: newScan();">newScan</button><br />
                    <button type="button" class="options" onClick="JavaScript:collectRun()">run</button><br />
                    <button type="button" class="options" onClick="JavaScript:collectPause()">pause</button><br />
                    <button type="button" class="options" onClick="JavaScript:collectStep()">step</button>
                </td>
                <td id="opt" class="options alt1">
                    IPMinMax 127.0.0.x:
                    <input type="text" value="0" class="options" size="5" id="IPMin">
                    <input type="text" value="0" class="options" size="5" id="IPMax">
                    <br />
                    Circle
                    <select id="circle" class="options">
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                        <option value="4">4</option>
                        <option value="5">5</option>
                        <option value="6">6</option>
                    </select>
                    Max. nodes
                    <select id="maxnodes" class="options">
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                    </select>
                    <select id="type" class="options">
                        <option value="BCNode" selected>BCNode</option>
                        <option value="Wallet">Wallet</option>
                        <option value="Miner">Miner</option>
                    </select>
                    <br />
                    Offset:
                    <input type="range" min="1" max="360" value="50" class="options" id="off1" oninput="drawCanvas();">
                    <br />
                    Size:
                    <input type="range" min="1" max="100" value="50" class="options" id="siz1" oninput="drawCanvas();">
                </td>
                <td id="opt" class="options alt2">
                    IPMinMax 127.0.0.x:
                    <input type="text" value="30" class="options" size="5" id="IPMin">
                    <input type="text" value="34" class="options" size="5" id="IPMax">
                    <br />
                    Circle
                    <select id="circle" class="options">
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                        <option value="4">4</option>
                        <option value="5">5</option>
                        <option value="6">6</option>
                    </select>
                    Max. nodes
                    <select id="maxnodes" class="options">
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                    </select>
                    <select id="type" class="options">
                        <option value="BCNode">BCNode</option>
                        <option value="Wallet">Wallet</option>
                        <option value="Miner" selected>Miner</option>
                    </select>
                    <br />
                    Offset:
                    <input type="range" min="1" max="360" value="50" class="options" id="off2" oninput="drawCanvas();">
                    <br />
                    Size:
                    <input type="range" min="1" max="100" value="50" class="options" id="siz2" oninput="drawCanvas();">
                </td>
                <td id="opt" class="options alt1">
                    IPMinMax 127.0.0.x:
                    <input type="text" value="50" class="options" size="5" id="IPMin">
                    <input type="text" value="54" class="options" size="5" id="IPMax">
                    <br />
                    Circle
                    <select id="circle" class="options">
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                        <option value="4">4</option>
                        <option value="5">5</option>
                        <option value="6">6</option>
                    </select>
                    Max. nodes
                    <select id="maxnodes" class="options">
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                    </select>
                    <select id="type" class="options">
                        <option value="BCNode">BCNode</option>
                        <option value="Wallet" selected>Wallet</option>
                        <option value="Miner">Miner</option>
                    </select>
                    <br />
                    Offset:
                    <input type="range" min="1" max="360" value="50" class="options" id="off3" oninput="drawCanvas();">
                    <br />
                    Size:
                    <input type="range" min="1" max="100" value="50" class="options" id="siz3" oninput="drawCanvas();">
                </td>
                <td id="opt" class="options alt2">
                    IPMinMax 127.0.0.x:
                    <input type="text" value="0" class="options" size="5" id="IPMin">
                    <input type="text" value="0" class="options" size="5" id="IPMax">
                    <br />
                    Circle
                    <select id="circle" class="options">
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                        <option value="4">4</option>
                        <option value="5">5</option>
                        <option value="6">6</option>
                    </select>
                    Max. nodes
                    <select id="maxnodes" class="options">
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                    </select>
                    <select id="type" class="options">
                        <option value="BCNode">BCNode</option>
                        <option value="Wallet">Wallet</option>
                        <option value="Miner">Miner</option>
                    </select>
                    <br />
                    Offset:
                    <input type="range" min="1" max="360" value="50" class="options" id="off4" oninput="drawCanvas();">
                    <br />
                    Size:
                    <input type="range" min="1" max="100" value="50" class="options" id="siz4" oninput="drawCanvas();">
                </td>
                <td id="opt" class="options alt1">
                    IPMinMax 127.0.0.x:
                    <input type="text" value="1" class="options" size="5" id="IPMin">
                    <input type="text" value="5" class="options" size="5" id="IPMax">
                    <br />
                    Circle
                    <select id="circle" class="options">
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                        <option value="4">4</option>
                        <option value="5">5</option>
                        <option value="6">6</option>
                    </select>
                    Max. nodes
                    <select id="maxnodes" class="options">
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                    </select>
                    <select id="type" class="options">
                        <option value="BCNode">BCNode</option>
                        <option value="Wallet">Wallet</option>
                        <option value="Miner">Miner</option>
                    </select>
                    <br />
                    Offset:
                    <input type="range" min="1" max="360" value="50" class="options" id="off5" oninput="drawCanvas();">
                    <br />
                    Size:
                    <input type="range" min="1" max="100" value="50" class="options" id="siz5" oninput="drawCanvas();">
                </td>
            </tr>
        </table>
    </div>
    <div id='radar' align="center">
        Refresh Data Rate <input type="range" min="350" max="2500" value="800" class="slider" id="refreshRate">
        Anim Delay <input type="range" min="10" max="500" value="150" class="slider" id="animDelay">
        Canvas Width <input type="range" min="100" max="1200" value="500" class="slider" id="twidth" oninput="resizeCanvas();">
        Canvas Height <input type="range" min="100" max="900" value="500" class="slider" id="theight" oninput="resizeCanvas();">
        <br />
        <canvas onmousemove="draw(event)" id="canvas" class="border">Oops, no canvas supported by your browser?</canvas>
    </div>
    REST-API log:
    <button type="button" onClick="document.getElementById('response').value=''">Reset Log</button>
    <div>
        <textarea id="response" cols="120" rows="15">
                    </textarea>
    </div>

    <script>
        ctx = null
        totalScan = 0;
        collectCount = 0;
        collect = false;
        initScan = true;
        maxIter = 32; 

        function clearDom(dom) {
            return dom.replace(/\./g, "").replace(/:/g, "").replace(/\//g, "");
        }

        $(document).ready(function () {
            ctx = $("#canvas")[0].getContext('2d');
            $("#scan").prop("checked", false);
            $("#ctrl").prop("checked", true);
            init();
            lastGUI = "";
            drawGrid();
        });

        function init() {
            nodes = {
                "B": {},
                "W": {},
                "M": {}
            }

            comNodes = []

            rings = [[], [], [], [], []]

            col = {
                "B": ['rgb(0,0,255)', 'rgb(0,255,255)', 'rgb(0,0,0)'],
                "M": ['rgb(210,105,30)', 'rgb(0,255,255)', 'rgb(0,0,0)'],
                "W": ['rgb(255,255,0)', 'rgb(0,255,255)', 'rgb(0,0,0)'],
            }

            animCol = {
                "info": ['rgb(0,0,255)', 'rgb(0,255,255)', 'rgb(0,0,0)'],
                "peers": ['rgb(210,105,30)', 'rgb(0,255,255)', 'rgb(0,0,0)'],
                "W": ['rgb(255,255,0)', 'rgb(0,255,255)', 'rgb(0,0,0)'],
            }
            ctx.canvas.width = getWidth();
            ctx.canvas.height = getHeight();
        }

        function getWidth() {
            return $("#twidth")[0].value
        }

        function getHeight() {
            return $("#theight")[0].value
        }
        function draw(evt) {
            globMousePos = getMousePos(ctx.canvas, evt);
        }

        function getMousePos(canvas, evt) {
            var rect = canvas.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }

        function resizeCanvas() {
            ctx.canvas.width = getWidth();
            ctx.canvas.height = getHeight();
            drawCanvas();
        }

        function hideFrames() {
            $(".iframes").each(function () {
                $(this).hide();
            });
            if (document.getElementById("ctrl").checked) {
                $("#views").show();
            } else {
                $("#views").hide();
            }
        }

        function setFramesHeight() {
            $(".iframes").each(function () {
                var h = $("#viewsizes").val() * 100;
                if (h == 0) {
                    $(this).hide();
                } else {
                    $(this).attr('height', h);
                }
            });
        }

        $("#viewsizes").change(function () {
            setFramesHeight();
        });

        $("canvas").dblclick(function () {
            hideFrames();
            for (var typ in nodes) {
                if (nodes.hasOwnProperty(typ)) {
                    for (var dom in nodes[typ]) {
                        var dx = getXYType(typ, dom);
                        if ((dx.x - dx.size < globMousePos.x) && (dx.x + dx.size > globMousePos.x) &&
                            (dx.y - dx.size < globMousePos.y) && (dx.y + dx.size > globMousePos.y)) {
                            lastGUI = "#" + clearDom(dom);
                            $("#" + clearDom(dom)).show();
                            return;
                        }
                    }
                }
            }
        });

        function collected(jsonIn, data) {
            var json = JSON.parse(jsonIn);
            if (json.hasOwnProperty("delayID")) {
                var typ = data[0];
                var from = data[1];
                var to = json.url;
                var pos = to.indexOf(":",6);
                if (pos > 0) {
                    var toDom = to.substring(0, pos + 5);
                    comNodes.push({ 'iter': 0, 'fromType': typ, 'fromDom': from, 'url': to,'toType':getType(toDom), 'toDom': toDom, 'delayID': json.delayID });
                }
            }
            drawCanvas();
        }

        function drawAllComs() {
            var lenc = comNodes.length;
            for (var com = 0; com < lenc; com++) {
                var item = comNodes[com];
                if (item.hasOwnProperty('delta')) {
                    var show = item.url.substring(item.url.indexOf("/", 8)+1);
                    var node = item.delta;
                    var gr = ctx.createRadialGradient(node.x, node.y, node.size / 4, node.x, node.y, node.size);
                    var cols = ['rgb(0,0,255)', 'rgb(0,255,255)', 'rgb(0,0,0)'];
                    if (animCol.hasOwnProperty(show)) {
                        cols = animCol[show];
                    }
                    gr.addColorStop(0, cols[0]);
                    gr.addColorStop(0.5, cols[1]);
                    gr.addColorStop(1, cols[2]);
                    ctx.fillStyle = gr;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, node.size, 0, Math.PI * 2, false);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = "black";
                    ctx.font = "10px _sans";
                    ctx.textBaseline = "top";
                    var use_y = node.y;
                    ctx.fillText(show, node.x , node.y+(node.toRight?-node.size*2:node.size));
                }
            }
        }

        function doCollect(contin) {
            if (collectCount <= 0) {
                for (var typ in nodes) {
                    if (nodes.hasOwnProperty(typ)) {
                        for (var dom in nodes[typ]) {
                            if (nodes[typ].hasOwnProperty(dom)) {
                                collectionCount++;
                                doGETCallback(dom + "/visualGet", collected, [typ, dom]);
                            }
                        }
                    }
                }
            }
            if ((collect == true) && contin) {
                var tim = +$("#refreshRate").val();
                setTimeout(function () { doCollect(true); }, tim);
            }

        }

        function collectRun() {
            collect = true;
            setTimeout(function () { doCollect(true);},100)
        }

        function collectPause() {
            collect = false;
        }

        function collectStep() {
            collect = false;
            doCollect(false);
        }

        setTimeout(function () { updateCom() }, 100);

        function releaseFor(url) {
            var xhttp = new XMLHttpRequest();
            xhttp.onreadystatechange = function () {
                if (this.readyState == 4) {
                    // we ignore reply for now, but maybe can make use of reply for animation....
                }
            };
            xhttp.open("GET", url, true);
            xhttp.send();
        }

        function updateCom() {
            var comNodesL = comNodes.length;
            if (comNodesL > 0) {
                for (var com = 0; com < comNodesL; com++) {
                    var item = comNodes[com];
                    if (item.iter >= maxIter) {
                        comNodes.splice(com, 1);
                        com--;
                        comNodesL--;
                        releaseFor(item.fromDom+"/visualRelease/"+item.delayID);
                        continue;
                    }
                    var from = getXYType(item.fromType, item.fromDom)
                    if (from.hasOwnProperty(item.toDom)) {;
                        var to = getXYType(item.toType, item.toDom);
                        var deltax = (to.x - from.x) / maxIter * item.iter;
                        var use_y = from.y;
                        var use_x = from.x;
                        var toright = true;
                        if (to.x<from.x) {
                            use_y += 7;
                            use_x -= 7;
                            toright = false;
                        } else {
                            use_y -= 9;
                            use_x += 9;
                        }

                        comNodes[com]['delta'] = { 'x': use_x + deltax, 'y': deltax * from[item.toDom].slope + use_y, 'size': 10 ,'toRight': toright};
                    } else {
                        console.log("No to Dom for " + com);
                        console.log(from);
                        comNodes[com]['delta'] = { 'x': from.x, 'y': from.y, 'size': 10 };
                    }
                }
                drawCanvas();
                for (var com = 0; com < comNodesL; com++) {
                    comNodes[com].iter = comNodes[com].iter + 1;
                }
            }
            setTimeout(function () { updateCom() },+$("#animDelay").val());
        }

        function newScan() {
            collectPause();
            init();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            collectSizes();
            drawGrid();
            //setTimeout(function () { reScan() }, 100);
            reScan();
        }

        $("#test").on("click", function () {
            ctx.save();
            setTimeout(function () { drawCom("W", "http://127.0.0.52:5555", "B", "http://127.0.0.2:5555", 0); }, 100);
        });

        $("#scan").on("change", function () {
            if (this.checked) {
                setTimeout(function () {
                    if (initScan == false) {
                        reScan();
                    } else {
                        newScan();
                    }
                }, 100);
            }
        });

        $("#ctrl").on("change", function () {
            if (this.checked) {
                $("#views").show();
            } else {
                $("#views").hide();
            }
        });

        $("#GUI").on("change", function () {
            if (this.checked) {
                $(lastGUI).show();
            } else {
                hideFrames();
            }
        });

        function setShadow(on) {
            ctx.shadowColor = 'black';
            ctx.shadowBlur = 10;
            ctx.shadowOffsetX = 5;
            ctx.shadowOffsetY = 5;
        }

        function reScan() {
            initScan = false;
            if (totalScan <= 0) {
                var scans = [];
                var ring = 0;
                $("td[id*='opt']").each(function () {
                    var min = parseInt($(this).find("#IPMin")[0].value);
                    var max = parseInt($(this).find("#IPMax")[0].value);
                    var typ = $(this).find("#type")[0];
                    // TODO alert ignore double
                    if ((min * max > 0) && (min > 0) && (min < 128) && (max < 128)) {
                        for (var ipx = min; ipx <= max; ipx++) {
                            //TODO get the scan directly here and only update the relevant ring!!!
                            scans.push([ipx, typ.value, ring]);
                        }
                    }
                    ring++;
                });
                totalScan = scans.length
                for (var i = 0; i < scans.length; i++) {
                    scanFor(scans[i][0], scans[i][1], scans[i][2]);
                }
                scans = [];
            }
            var sc = $("#scan");
            if (sc.is(":checked")) {
                setTimeout(function () { reScan() }, 5000);
            }
        }

        function scanFor(ipIn, typIn, ringIn) {
            var ip = ipIn;
            var typ = typIn.substring(0, 1);
            var ring = ringIn;
            port = 5555
            var dom = "http://127.0.0." + ip + ":" + port
            var url = dom + "/cfg";
            var xhttp = new XMLHttpRequest();
            xhttp.onreadystatechange = function () {
                if (this.readyState == 4) {
                    addLog("\n(" + typ + ") Reply:" + url, false);
                    var avail = nodes[typ]
                    if (this.status == 200) {
                        text = this.responseText;
                        jstext = JSON.parse(text);
                        if (jstext['type'].startsWith(typ)) {
                            var found = false
                            for (var i = 0; i < rings[ring].length; i++) {
                                if (rings[ring][i] == dom) {
                                    found = true;
                                    break;
                                }
                            }
                            if (found == false) {
                                rings[ring].push(dom);
                            }
                            if (avail.hasOwnProperty(dom)) {
                                nodes[typ][dom]['ping'] = true;
                            } else {
                                nodes[typ][dom] = { "ping": true, "ring": ring, "cfg": jstext, "peers": jstext['peers'] };
                            }

                            if (!text.startsWith("[]")) {
                                addLog("\n" + text, false);
                            } else {
                                addLog(" ===> []", false);
                            }
                            if (found == false) {
                                $('<iframe src="' + dom + '" frameborder="1" class="iframes" scrolling="yes" id="' + clearDom(dom) + '" title="' + dom + '" width="100%"></iframe>')
                                    .appendTo('#control').hide();
                                setFramesHeight();
                            }
                        } else {
                            addLog("Wrong node detected in range: " + jstext['type'] + "for ring " + ring + " expected " + typ);
                        }
                    } else {
                        text = " ==> Error: " + this.status + " with '" + this.responseText + "'";
                        addLog(text, false);
                        if (avail.hasOwnProperty(dom)) {
                            nodes[typ][dom]['ping'] = false;
                        } else {

                        }
                    }
                    totalScan--;
                    drawCanvas();
                }
            };
            xhttp.open("GET", url, true);
            xhttp.send();
        }

        // helper function to show results as
        function addLog(text, start) {
            if (start == true) {
                ntext = "\n---- [Command count:" + cnt + "]" + text
                cnt++
            } else {
                //ntext = "\n\r==> Reply:\n\r"+text
                ntext = text
            }
            //document.getElementById("response").value = document.getElementById("response").value + ntext;
            return ntext
        }

        function drawNode(typ, dom, node, cols) {
            var n = nodes[typ];
            if (n.hasOwnProperty(dom)) {
                var item = n[dom]
                if (item['ping'] === true) {
                    var gr = ctx.createRadialGradient(node.x, node.y, node.size / 4, node.x, node.y, node.size);
                    gr.addColorStop(0, cols[0]);
                    gr.addColorStop(0.5, cols[1]);
                    gr.addColorStop(1, cols[2]);
                    ctx.fillStyle = gr;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, node.size, 0, Math.PI * 2, false);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    var gr = ctx.createRadialGradient(node.x, node.y, node.size / 4, node.x, node.y, node.size);
                    gr.addColorStop(0, cols[0]);
                    gr.addColorStop(0.5, "red");
                    gr.addColorStop(1, "orange");
                    ctx.fillStyle = gr;
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, node.size, 0, Math.PI * 2, false);
                    ctx.closePath();
                    ctx.fill();
                }
                ctx.fillStyle = "black";
                ctx.font = "10px _sans";
                ctx.textBaseline = "top";
                var ipa = typ
                var pos = dom.lastIndexOf(":")
                if (pos > 0) {
                    ipa = dom.substring(0, pos);
                    pos = ipa.lastIndexOf(".");
                    if (pos > 0) {
                        ipa = typ + "/" + ipa.substring(pos + 1);
                    }
                }
                ctx.fillText(ipa, node.x - node.size / 2, node.y);
                return true;
            }
            return false;
        }

        function collectSizes() {
            setSizes = [];
            rot = [];
            for (var i = 1; i < rings.length + 1; i++) {
                setSizes.push(+$("#siz" + i)[0].value);
                rot.push(+$("#off" + i)[0].value);
            }
        }

        function drawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            collectSizes();
            calcCoords();
            drawGrid();
            drawLines();
            ctx.save();
            setShadow(true);
            drawAllNodes();
            ctx.restore();
            drawAllComs();
        }

        function drawGrid() {
            ctx.setLineDash([5, 5])
            var sradx = Math.trunc((getWidth() * .45) / (rings.length * 1));
            var srady = Math.trunc((getHeight() * .45) / (rings.length * 1));
            var center_x = getWidth() / 2;
            var center_y = getHeight() / 2;
            ctx.strokeStyle = "lightgrey";
            ctx.fillStyle = "lightgrey";
            ctx.lineWidth = 1;
            ctx.strokeWidth = 1;

            for (var ring = 1; ring <= rings.length; ring++) {
                ctx.beginPath();
                ctx.ellipse(center_x, center_y, sradx * ring, srady * ring, 0, 2 * Math.PI, false);
                ctx.stroke();
            }
            ctx.setLineDash([])
        }

        function setXY(typ, dom, x, y, size) {
            if (nodes.hasOwnProperty(typ) && nodes[typ].hasOwnProperty(dom)) {
                nodes[typ][dom]['draw'] = { 'x': x, 'y': y, 'size': size };
            }
        }

        function getXYType(typ, dom) {
            if (nodes.hasOwnProperty(typ)) {
                if (nodes[typ].hasOwnProperty(dom)) {
                    return nodes[typ][dom]['draw'];
                }
            }
            return {}
        }

        function getXY(dom) {
            for (var typ in nodes) {
                if (nodes.hasOwnProperty(typ)) {
                    if (nodes[typ].hasOwnProperty(dom)) {
                        return nodes[typ][dom]['draw'];
                    }
                }
            }
            return {}
        }

        function getType(dom) {
            for (var typ in nodes) {
                if (nodes.hasOwnProperty(typ)) {
                    if (nodes[typ].hasOwnProperty(dom)) {
                        return typ;
                    }
                }
            }
            console.log("not found " + dom);
            return "";
        }

        function calcCoords() {
            var sradx = Math.trunc((getWidth() * .45) / (rings.length * 1));
            var srady = Math.trunc((getHeight() * .45) / (rings.length * 1));

            var center_x = getWidth() / 2;
            var center_y = getHeight() / 2;

            for (var ring = 0; ring < rings.length; ring++) {
                r = rings[ring];
                var radiusx = sradx * (ring + 1);
                var radiusy = srady * (ring + 1);
                var size = (sradx * 2 / 3) * (setSizes[ring] / 100);
                size = Math.min(size, (srady * 2 / 3) * (setSizes[ring] / 100));
                for (var rr = 0; rr < r.length; rr++) {
                    var angle = ((360 / r.length) * rr + rot[ring]) * Math.PI / 180;
                    var x = center_x + radiusx * Math.cos(angle);
                    var y = center_y + radiusy * Math.sin(angle);
                    if (!setXY("B", r[rr], x, y, size)) {
                        if (!setXY("W", r[rr], x, y, size)) {
                            if (!setXY("M", r[rr], x, y, size)) {
                                //???
                            }
                        }
                    }
                }
            }

            for (var typ in nodes) {
                if (nodes.hasOwnProperty(typ)) {
                    for (var dom in nodes[typ]) {
                        if (nodes[typ].hasOwnProperty(dom)) {
                            var drawFrom = getXY(dom);
                            for (var peer in nodes[typ][dom]['peers']) {
                                if (nodes[typ][dom]['peers'].hasOwnProperty(peer)) {
                                    var drawTo = getXY(peer);
                                    if (Object.keys(drawTo).length > 0) {
                                        var slope = (drawTo.y - drawFrom.y) / (drawTo.x - drawFrom.x);
                                        nodes[typ][dom]['draw'][peer] = { 'slope': slope };
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        function drawAllNodes() {
            for (var typ in nodes) {
                if (nodes.hasOwnProperty(typ)) {
                    for (var dom in nodes[typ]) {
                        var dx = getXYType(typ, dom);
                        if (Object.keys(dx).length > 2) {
                            drawNode(typ, dom, dx, col[typ]);
                        }
                    }
                }
            }
        }


        function drawArrow(fromx, fromy, tox, toy, size) {
            //variables to be used when creating the arrow
            var headlen = size;

            var angle = Math.atan2(toy - fromy, tox - fromx);

            //starting a new path from the head of the arrow to one of the sides of the point
            ctx.beginPath();
            ctx.moveTo(tox, toy);
            ctx.lineTo(tox - headlen * Math.cos(angle - Math.PI / 7), toy - headlen * Math.sin(angle - Math.PI / 7));

            //path from the side point of the arrow, to the other side point
            ctx.lineTo(tox - headlen * Math.cos(angle + Math.PI / 7), toy - headlen * Math.sin(angle + Math.PI / 7));

            //path from the side point back to the tip of the arrow, and then again to the opposite side point
            ctx.lineTo(tox, toy);
            ctx.lineTo(tox - headlen * Math.cos(angle - Math.PI / 7), toy - headlen * Math.sin(angle - Math.PI / 7));

            //draws the paths created above
            ctx.lineWidth = 5;
            ctx.stroke();
            ctx.fill();
        }

        function arrow(from, to) {
            var mx = (from.x + to.x) / 2;
            var my = (from.y + to.y) / 2;
            var mx2 = (from.x + mx) / 2;
            var my2 = (from.y + my) / 2;
            mx = (mx2 + mx) / 2;
            my = (my2 + my) / 2;
            drawArrow(from.x, from.y, mx, my, 1);
        }

        function drawLines() {
            //nodes[typ][dom] = { "ping": true, "ring": ring, "cfg": jstext };
            for (var typ in nodes) {
                if (nodes.hasOwnProperty(typ)) {
                    for (var dom in nodes[typ]) {
                        if (nodes[typ].hasOwnProperty(dom)) {
                            var drawFrom = getXY(dom);
                            for (var peer in nodes[typ][dom]['peers']) {
                                if (nodes[typ][dom]['peers'].hasOwnProperty(peer)) {
                                    var drawTo = getXY(peer);
                                    if (Object.keys(drawTo).length > 0) {
                                        ctx.strokeStyle = 'green';
                                        if (nodes[typ][dom]['ping'] == false) {
                                            ctx.strokeStyle = 'orange';
                                        }
                                        ctx.lineWidth = 2;
                                        ctx.beginPath();
                                        ctx.moveTo(drawFrom.x, drawFrom.y);
                                        ctx.lineTo(drawTo.x, drawTo.y);
                                        ctx.stroke();
                                        ctx.closePath();
                                        arrow(drawFrom, drawTo);
                                    }
                                    else {
                                        ctx.strokeStyle = 'red';
                                        ctx.lineWidth = 2;
                                        ctx.beginPath();
                                        ctx.moveTo(drawFrom.x, drawFrom.y);
                                        ctx.lineTo(0, 0);
                                        ctx.stroke();
                                        ctx.closePath();
                                    }

                                }
                            }
                        }
                    }
                }
            }
        }
        function doGETCallback(url, callBack, callBackData) {
            keep = ""
            port = 5555;
            if (port < 1024) {
                newContent = "No Port";
            } else {
                //var url = fillURL(url);
                var xhttp = new XMLHttpRequest();
                xhttp.onreadystatechange = function () {
                    if (this.readyState == 4) {
                        collectCount--;
                        callBack(this.responseText, callBackData);
                    }
                };
                xhttp.open("GET", url, true);
                xhttp.send();
            }
        }
    </script>
</body>
</html>